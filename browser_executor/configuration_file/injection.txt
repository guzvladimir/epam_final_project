exec("""\nimport sys\nimport traceback\n\n\ndef check_usage_possibility(func, importing_module=None):\n    def inner(*args, **kwargs):\n        usage_counter = 0\n        stack = traceback.extract_stack()\n        for line in stack:\n            if line[0] == '<string>':\n                usage_counter += 1\n        try:\n            if not importing_module:\n                blocked_function = inner.__name__\n                if usage_counter == len(stack):\n                    raise PermissionError(f"Function {blocked_function} is not allowed to use")\n\n            blocked_import = args[0]\n            if usage_counter == len(stack) and blocked_import == importing_module:\n                raise PermissionError(f"Module {blocked_import} is not allowed to use")\n\n        except PermissionError as message:\n            print(message)\n            sys.exit()\n\n        return func(*args, **kwargs)\n\n    inner.__name__ = func.__name__\n    return inner\n\n\nfor blocked_import in sys.argv[1].split(','):\n    __builtins__.__dict__['__import__'] = check_usage_possibility(__builtins__.__dict__['__import__'], blocked_import)\nfor blocked_function in sys.argv[2].split(','):\n    __builtins__.__dict__[blocked_function] = check_usage_possibility(__builtins__.__dict__['exec'])\n\ndel check_usage_possibility\n\n""")